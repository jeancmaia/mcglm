<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mcglm.mcglmcattr &mdash; mcglm 0.2.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=6ffd866b"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            mcglm
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">mcglm</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mcglm</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mcglm.mcglmcattr</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mcglm.mcglmcattr</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>


<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">tril</span><span class="p">,</span> <span class="n">kron</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">cholesky</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">mc_sandwich</span><span class="p">,</span>
    <span class="n">diagonal</span><span class="p">,</span>
    <span class="n">mc_sandwich_power</span><span class="p">,</span>
    <span class="n">mc_matrix_linear_predictor</span><span class="p">,</span>
    <span class="n">mc_sandwich_power_csr</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="MCGLMCAttributes">
<a class="viewcode-back" href="../../mcglm.html#mcglm.mcglmcattr.MCGLMCAttributes">[docs]</a>
<span class="k">class</span> <span class="nc">MCGLMCAttributes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class &quot;MCGLMCAttributes&quot; has the sake of calculating every C operations, used on throughout adjustments of mean and variance. This class has two interfaces, &quot;c_inverse&quot; and &quot;c_complete&quot;; one for each of two adjustment steps of MCGLM.</span>

<span class="sd">    The interface &quot;c_inverse&quot; crafts only inverse C, and the &quot;c_complete&quot; adds its derivatives and other features onto response. A Quasi-likelihood estimation needs only the inverse of &quot;C&quot; matrix. Therefore c_inverse saves computational resources by avoiding unnecessary operations on mean step adjustment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MCGLMCAttributes.c_inverse">
<a class="viewcode-back" href="../../mcglm.html#mcglm.mcglmcattr.MCGLMCAttributes.c_inverse">[docs]</a>
    <span class="k">def</span> <span class="nf">c_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">full_response</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A method to generate only the inverse of the C matrix, explicitly made for the mean treatment step. This method interacts with sigma and omega amenities by list of each parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mu : array_like</span>
<span class="sd">                A vetor with mean parameters.</span>
<span class="sd">            power : float</span>
<span class="sd">                Power parameter.</span>
<span class="sd">            rho : float</span>
<span class="sd">                Correlation parameter.</span>
<span class="sd">            tau : float</span>
<span class="sd">                Dispersion parameter.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like or tuple : The inverse of C matrix and its components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_inverse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_c_inverse</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">full_response</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c_inverse</span></div>


<div class="viewcode-block" id="MCGLMCAttributes.c_complete">
<a class="viewcode-back" href="../../mcglm.html#mcglm.mcglmcattr.MCGLMCAttributes.c_complete">[docs]</a>
    <span class="k">def</span> <span class="nf">c_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A method to generate the whole list of C components, explicitly made for the variance treatment step. This method interacts with sigma and omega crafting practices, passing the list of each parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mu : array_like</span>
<span class="sd">                A vetor with mean parameters.</span>
<span class="sd">            power : float</span>
<span class="sd">                Power parameter.</span>
<span class="sd">            rho : float</span>
<span class="sd">                Correlation parameter.</span>
<span class="sd">            tau : float</span>
<span class="sd">                Dispersion parameter.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            tuple : A tuple with every component of C.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">diagonal_matrix</span><span class="p">,</span>
            <span class="n">omega</span><span class="p">,</span>
            <span class="n">sigma_raw</span><span class="p">,</span>
            <span class="n">sigma_chol</span><span class="p">,</span>
            <span class="n">sigma_chol_inv</span><span class="p">,</span>
            <span class="n">sigma_between</span><span class="p">,</span>
            <span class="n">sigma_between_derivative</span><span class="p">,</span>
            <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
            <span class="n">sigma_chol_inv_block_matrix</span><span class="p">,</span>
            <span class="n">c_inverse</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_c_inverse</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">full_response</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sigma_derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_sigma_derivatives</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>

        <span class="n">core_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sigma_between</span><span class="p">,</span> <span class="n">diagonal_matrix</span><span class="p">)</span>
        <span class="n">sigma_chol_block_matrix_transpose</span> <span class="o">=</span> <span class="n">sigma_chol_block_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">c_derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_derivative_c</span><span class="p">(</span>
            <span class="n">sigma_chol</span><span class="p">,</span>
            <span class="n">sigma_chol_inv</span><span class="p">,</span>
            <span class="n">sigma_derivatives</span><span class="p">,</span>
            <span class="n">core_matrix</span><span class="p">,</span>
            <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
            <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
            <span class="n">sigma_between_derivative</span><span class="p">,</span>
            <span class="n">diagonal_matrix</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_targets</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">c_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_c_values</span><span class="p">(</span>
            <span class="n">sigma_between</span><span class="p">,</span>
            <span class="n">diagonal_matrix</span><span class="p">,</span>
            <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
            <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">c_inverse</span><span class="p">,</span> <span class="n">c_derivatives</span><span class="p">,</span> <span class="n">c_values</span></div>


    <span class="k">def</span> <span class="nf">__generate_c_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">full_response</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This method generates and retrieves the inverse of the C matrix, which is a pivotal component of the quasi-score calculation. Notwithstanding the mentioned, this method crafts many important artifacts throughout the time as omega, sigma, sigma Cholesky, the inverse of Cholesky sigma, sigma among responses, sigma block diagonal matrix alongside its inverse.</span>
<span class="sd">        Owing to the previously mentioned worthy artifacts crafted by the method, it can retrieve either only the c inverse matrix or all artifacts. The former is helpful for the method _c_inverse, whereas the former is for _c_complete.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mu : array-like</span>
<span class="sd">                A vetor with mean parameters.</span>
<span class="sd">            power : float</span>
<span class="sd">                Power parameter.</span>
<span class="sd">            rho : float</span>
<span class="sd">                Correlation parameter.</span>
<span class="sd">            tau : float</span>
<span class="sd">                Dispersion parameter.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like : A matrix with the inverse matrix of C.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diagonal_matrix</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_obs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_obs</span><span class="p">))</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_omega</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">build_sigma</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_sigma</span><span class="p">,</span>
            <span class="n">mu</span><span class="p">,</span>
            <span class="n">power</span><span class="p">,</span>
            <span class="n">omega</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variance</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ntrial</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sigma_raw</span><span class="p">,</span> <span class="n">sigma_chol</span><span class="p">,</span> <span class="n">sigma_chol_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parser_sigma</span><span class="p">(</span><span class="n">build_sigma</span><span class="p">)</span>

        <span class="n">sigma_between</span><span class="p">,</span> <span class="n">sigma_between_derivative</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_between_values</span><span class="p">(</span>
            <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">n_resp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_targets</span>
        <span class="p">)</span>
        <span class="n">raw_c_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_c_inverse_and_blocks</span><span class="p">(</span>
            <span class="n">sigma_chol</span><span class="p">,</span> <span class="n">sigma_chol_inv</span><span class="p">,</span> <span class="n">sigma_between</span><span class="p">,</span> <span class="n">diagonal_matrix</span>
        <span class="p">)</span>

        <span class="p">(</span>
            <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
            <span class="n">sigma_chol_inv_block_matrix</span><span class="p">,</span>
            <span class="n">c_inverse</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parser_c_inverse</span><span class="p">(</span><span class="n">raw_c_components</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">full_response</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c_inverse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">diagonal_matrix</span><span class="p">,</span>
                <span class="n">omega</span><span class="p">,</span>
                <span class="n">sigma_raw</span><span class="p">,</span>
                <span class="n">sigma_chol</span><span class="p">,</span>
                <span class="n">sigma_chol_inv</span><span class="p">,</span>
                <span class="n">sigma_between</span><span class="p">,</span>
                <span class="n">sigma_between_derivative</span><span class="p">,</span>
                <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
                <span class="n">sigma_chol_inv_block_matrix</span><span class="p">,</span>
                <span class="n">c_inverse</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__generate_sigma_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base method to generate derivatives related to sigma.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            omega : array-like</span>
<span class="sd">                The omega matrix.</span>
<span class="sd">            mu : array-like</span>
<span class="sd">                A vetor with mean parameters.</span>
<span class="sd">            power : float</span>
<span class="sd">                The power parameter.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            _type_: _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">build_sigma</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_sigma_derivatives</span><span class="p">,</span>
            <span class="n">mu</span><span class="p">,</span>
            <span class="n">power</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variance</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_power_fixed</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ntrial</span><span class="p">,</span>
            <span class="n">omega</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">sigma_derivative</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parser_sigma_derivatives</span><span class="p">(</span><span class="n">build_sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sigma_derivative</span>

    <span class="k">def</span> <span class="nf">__generate_derivative_c</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma_chol</span><span class="p">,</span>
        <span class="n">sigma_chol_inv</span><span class="p">,</span>
        <span class="n">sigma_derivatives</span><span class="p">,</span>
        <span class="n">core_matrix</span><span class="p">,</span>
        <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
        <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
        <span class="n">sigma_between_derivative</span><span class="p">,</span>
        <span class="n">diagonal_matrix</span><span class="p">,</span>
        <span class="n">n_target</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base method to generate derivatives related to C matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            sigma_chol : array_like</span>
<span class="sd">                Sigma matrix decomposed by the Cholesky operation.</span>
<span class="sd">            sigma_chol_inv : array_like</span>
<span class="sd">                Inverse sigma matrix decomposed by the Cholesky operation.</span>
<span class="sd">            sigma_derivatives : array_like</span>
<span class="sd">                Derivatives related to the Sigma.</span>
<span class="sd">            core_matrix : array_like</span>
<span class="sd">                An intermediate matrix for Sigma operation</span>
<span class="sd">            sigma_chol_block_matrix : array_like</span>
<span class="sd">                A block diagonal matrix with all Sigmas.</span>
<span class="sd">            sigma_chol_block_matrix_transpose : array_like</span>
<span class="sd">                The transpose matrix of a block diagonal matrix with all Sigmas.</span>
<span class="sd">            sigma_between_derivative : array_like</span>
<span class="sd">                The deriviatives between sigmas.</span>
<span class="sd">            diagonal_matrix : array_like</span>
<span class="sd">                A diagonal matrix.</span>
<span class="sd">            n_target : int</span>
<span class="sd">                Total outcome variables.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like : A matrix with derivatives related to the C Matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_target</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">core_matrix_csr</span> <span class="o">=</span> <span class="n">sigma_between_derivative</span>
            <span class="n">sigma_chol_block_matrix_csr</span> <span class="o">=</span> <span class="n">sigma_chol_block_matrix</span>
            <span class="n">sigma_chol_block_matrix_transpose_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span>
                <span class="n">sigma_chol_block_matrix_transpose</span>
            <span class="p">)</span>
            <span class="n">sigma_between_derivative_csr</span> <span class="o">=</span> <span class="n">sigma_between_derivative</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">core_matrix_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">core_matrix</span><span class="p">)</span>
            <span class="n">sigma_chol_block_matrix_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">sigma_chol_block_matrix</span><span class="p">)</span>
            <span class="n">sigma_chol_block_matrix_transpose_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span>
                <span class="n">sigma_chol_block_matrix_transpose</span>
            <span class="p">)</span>
            <span class="n">sigma_between_derivative_csr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">sigma_between_derivative</span><span class="p">:</span>
                <span class="n">sigma_between_derivative_csr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>

            <span class="n">diagonal_matrix_csr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">diagonal_matrix</span><span class="p">)</span>

        <span class="n">list_d_chol_sigma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__derivative_cholesky</span><span class="p">,</span>
                <span class="n">sigma_derivatives</span><span class="p">,</span>
                <span class="n">sigma_chol_inv</span><span class="p">,</span>
                <span class="n">sigma_chol</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">bdiag_d_chol_sigma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__mc_transform_list_bdiag</span><span class="p">,</span>
                <span class="n">list_d_chol_sigma</span><span class="p">,</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_target</span><span class="p">)),</span>
                <span class="p">[</span><span class="n">n_target</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">bdiag_d_chol_sigma_csr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sigmas</span> <span class="ow">in</span> <span class="n">bdiag_d_chol_sigma</span><span class="p">:</span>
            <span class="n">bdiag_d_chol_sigma_csr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">sigmas</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">n_target</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bdiag_d_chol_sigma_csr</span> <span class="o">=</span> <span class="n">bdiag_d_chol_sigma_csr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_c</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">mc_sandwich_power_csr</span><span class="p">(</span>
                    <span class="n">core_matrix_csr</span><span class="p">,</span>
                    <span class="n">d_chol_sigma</span><span class="p">,</span>
                    <span class="n">sigma_chol_block_matrix_transpose_csr</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">d_chol_sigma</span> <span class="ow">in</span> <span class="n">bdiag_d_chol_sigma_csr</span>
            <span class="p">]</span>
            <span class="n">D_C</span> <span class="o">=</span> <span class="n">d_c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bdiag_d_chol_sigma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">bdiag_d_chol_sigma_csr</span><span class="p">)))</span>

            <span class="n">d_c</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">mc_sandwich_power_csr</span><span class="p">(</span>
                    <span class="n">core_matrix_csr</span><span class="p">,</span>
                    <span class="n">d_chol_sigma</span><span class="p">,</span>
                    <span class="n">sigma_chol_block_matrix_transpose_csr</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">d_chol_sigma</span> <span class="ow">in</span> <span class="n">bdiag_d_chol_sigma</span>
            <span class="p">]</span>
            <span class="n">d_c_rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__derivative_rho</span><span class="p">(</span>
                <span class="n">sigma_between_derivative_csr</span><span class="p">,</span>
                <span class="n">sigma_chol_block_matrix_csr</span><span class="p">,</span>
                <span class="n">sigma_chol_block_matrix_transpose_csr</span><span class="p">,</span>
                <span class="n">diagonal_matrix_csr</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">D_C</span> <span class="o">=</span> <span class="n">d_c_rho</span> <span class="o">+</span> <span class="n">d_c</span>
        <span class="k">return</span> <span class="n">D_C</span>

    <span class="k">def</span> <span class="nf">__generate_c_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma_between</span><span class="p">,</span>
        <span class="n">diagonal_matrix</span><span class="p">,</span>
        <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
        <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;base method to generate the C matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            sigma_between : array_like</span>
<span class="sd">                Matrix with inner values among sigmas.</span>
<span class="sd">            diagonal_matrix : array_like</span>
<span class="sd">                A diagonal matrix.</span>
<span class="sd">            sigma_chol_block_matrix_transpose : array_like</span>
<span class="sd">                The transpose matrix of a block diagonal matrix with all Sigmas.</span>
<span class="sd">            sigma_chol_block_matrix : array_like</span>
<span class="sd">                A block diagonal matrix with all Sigmas.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like : A matrix with derivatives related to the C Matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kron_middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sigma_between</span><span class="p">,</span> <span class="n">diagonal_matrix</span><span class="p">)</span>

        <span class="n">c_computation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
                <span class="n">kron_middle</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">c_computation</span>

    <span class="k">def</span> <span class="nf">__derivative_rho</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">d_sigmab</span><span class="p">,</span>
        <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
        <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
        <span class="n">core_matrix</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base method to calculate derivatives related to correlation parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            d_sigmab : array_like</span>
<span class="sd">                Matrix with inner values among sigmas.</span>
<span class="sd">            sigma_chol_block_matrix : array_like</span>
<span class="sd">                A block diagonal matrix with all Sigmas.</span>
<span class="sd">            sigma_chol_block_matrix_transpose : array_like</span>
<span class="sd">                The transpose matrix of a block diagonal matrix with all Sigmas.</span>
<span class="sd">            core_matrix : array_like</span>
<span class="sd">                A diagonal matrix.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like : A matrix with derivatives related to the C Matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">multiplication_matrix</span><span class="p">(</span>
            <span class="n">sigmab</span><span class="p">,</span>
            <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
            <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
            <span class="n">core_matrix</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">kron_matrix</span> <span class="o">=</span> <span class="n">kron</span><span class="p">(</span><span class="n">sigmab</span><span class="p">,</span> <span class="n">core_matrix</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sigma_chol_block_matrix_transpose</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kron_matrix</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">sigma_chol_block_matrix</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">multiplication_matrix</span><span class="p">(</span>
                <span class="n">sigmab</span><span class="p">,</span>
                <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
                <span class="n">sigma_chol_block_matrix_transpose</span><span class="p">,</span>
                <span class="n">core_matrix</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sigmab</span> <span class="ow">in</span> <span class="n">d_sigmab</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_generate_omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base method to calculate derivatives related to correlation parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            tau : list</span>
<span class="sd">                List with dispersion parameters</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            list : the results of matrix linear sum between tau and dependence matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_targets</span><span class="p">):</span>
            <span class="n">omega</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mc_matrix_linear_predictor</span><span class="p">(</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="n">z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">[</span><span class="n">target</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">omega</span>

    <span class="k">def</span> <span class="nf">__generate_c_inverse_and_blocks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sigma_chol</span><span class="p">,</span>
        <span class="n">sigma_chol_inv</span><span class="p">,</span>
        <span class="n">sigma_between</span><span class="p">,</span>
        <span class="n">diagonal_matrix</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base method to calculate derivatives related to correlation parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            sigma_chol : array_like</span>
<span class="sd">                The sigma matrix decomposed by Cholesky.</span>
<span class="sd">            sigma_chol_inv : array_like</span>
<span class="sd">                The inverse of sigma matrix decomposed by Cholesky.</span>
<span class="sd">            sigma_between : array_like</span>
<span class="sd">                The inner-matrix among sigmas.</span>
<span class="sd">            diagonal_matrix : array_like</span>
<span class="sd">                A diagonal matrix.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like : A matrix with derivatives related to the C Matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_chol_block_matrix</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">sigma_chol</span><span class="p">)</span>
        <span class="n">sigma_chol_inv_block_matrix</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">sigma_chol_inv</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ls_sigma_diagonal</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">sigma_between</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">ls_sigma_diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">C_inverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">sigma_chol_inv_block_matrix</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">ls_sigma_diagonal</span><span class="p">,</span> <span class="n">diagonal_matrix</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="n">sigma_chol_inv_block_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">sigma_chol_block_matrix</span><span class="p">,</span>
            <span class="n">sigma_chol_inv_block_matrix</span><span class="p">,</span>
            <span class="n">C_inverse</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_sigma</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">Ntrial</span><span class="p">,</span> <span class="n">covariance</span><span class="o">=</span><span class="s2">&quot;identity&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base method to calculate sigma</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mu : array_like</span>
<span class="sd">                A vector with expected values.</span>
<span class="sd">            power : float</span>
<span class="sd">                A power parameter.</span>
<span class="sd">            omega : array_like</span>
<span class="sd">                The omega resulted matrix.</span>
<span class="sd">            variance : str</span>
<span class="sd">                The variance function.</span>
<span class="sd">            Ntrial : int</span>
<span class="sd">                The number of trial. Parameter for Binomial distribution.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like : A matrix with Sigma values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
            <span class="n">sigma_raw</span> <span class="o">=</span> <span class="n">omega</span>
            <span class="n">sigma_chol</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">sigma_raw</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">sigma_chol_inv</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">sigma_chol</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">variance</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tweedie&quot;</span><span class="p">,</span> <span class="s2">&quot;binomialP&quot;</span><span class="p">,</span> <span class="s2">&quot;binomialPQ&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="s2">&quot;tweedie&quot;</span><span class="p">:</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="s2">&quot;power&quot;</span>

            <span class="n">variance_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_variance</span><span class="p">(</span>
                <span class="n">variance_type</span><span class="o">=</span><span class="n">variance</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">),</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span> <span class="n">Ntrial</span><span class="o">=</span><span class="n">Ntrial</span>
            <span class="p">)</span>
            <span class="n">sigma_raw</span> <span class="o">=</span> <span class="n">mc_sandwich</span><span class="p">(</span>
                <span class="n">omega</span><span class="p">,</span>
                <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">sigma_chol</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">sigma_raw</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">sigma_chol_inv</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">sigma_chol</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">variance</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;poisson_tweedie&quot;</span><span class="p">,</span> <span class="s2">&quot;geom_tweedie&quot;</span><span class="p">]:</span>
            <span class="n">diagonal_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">mu</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mu</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">)][</span>
                <span class="n">variance</span> <span class="o">==</span> <span class="s2">&quot;poisson_tweedie&quot;</span>
            <span class="p">]</span>

            <span class="n">variance_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_variance</span><span class="p">(</span>
                <span class="n">variance_type</span><span class="o">=</span><span class="s2">&quot;power&quot;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">),</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span> <span class="n">Ntrial</span><span class="o">=</span><span class="n">Ntrial</span>
            <span class="p">)</span>
            <span class="n">sigma_raw</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">)),</span> <span class="n">diagonal_value</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span> <span class="n">omega</span><span class="p">),</span>
                <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">sigma_chol</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">sigma_raw</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">sigma_chol_inv</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">sigma_chol</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">sigma_raw</span><span class="o">=</span><span class="n">sigma_raw</span><span class="p">,</span> <span class="n">sigma_chol</span><span class="o">=</span><span class="n">sigma_chol</span><span class="p">,</span> <span class="n">sigma_chol_inv</span><span class="o">=</span><span class="n">sigma_chol_inv</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_sigma_derivatives</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">power_fixed</span><span class="p">,</span> <span class="n">Ntrial</span><span class="p">,</span> <span class="n">omegas</span><span class="p">,</span> <span class="n">covariance</span><span class="o">=</span><span class="s2">&quot;identity&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base method for computing variance-covariance matrix, based on variance function and omega matrix. This method will implement for cases where covariance is equal to identity, and variance falls in the list:</span>
<span class="sd">        [&#39;constant&#39;, &#39;tweedie&#39;, &#39;binomialP&#39;, &#39;binomialPQ&#39;, &#39;power&#39;, &#39;geom_tweedie&#39;, &#39;poisson_tweedie&#39;]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mu : array_like</span>
<span class="sd">                A vector with expected values.</span>
<span class="sd">            power : float</span>
<span class="sd">                A power parameter.</span>
<span class="sd">            variance : str</span>
<span class="sd">                The variance function.</span>
<span class="sd">            z : list</span>
<span class="sd">                The list with z matrices for dependencies specification.</span>
<span class="sd">            power_fixed : boolean</span>
<span class="sd">                The specification of power estimation.</span>
<span class="sd">            Ntrial : int</span>
<span class="sd">                The number of trial. Parameter for Binomial distribution.</span>
<span class="sd">            omegas : list</span>
<span class="sd">                a list with omegas.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sigma_derivative</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
            <span class="n">sigma_derivative</span> <span class="o">=</span> <span class="n">z</span>
        <span class="k">elif</span> <span class="n">variance</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tweedie&quot;</span><span class="p">,</span> <span class="s2">&quot;binomialP&quot;</span><span class="p">,</span> <span class="s2">&quot;binomialPQ&quot;</span><span class="p">]:</span>
            <span class="n">variance_type</span> <span class="o">=</span> <span class="n">variance</span> <span class="k">if</span> <span class="n">variance</span> <span class="o">!=</span> <span class="s2">&quot;tweedie&quot;</span> <span class="k">else</span> <span class="s2">&quot;power&quot;</span>

            <span class="n">variance_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_variance</span><span class="p">(</span>
                <span class="n">variance_type</span><span class="o">=</span><span class="n">variance_type</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">),</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span> <span class="n">Ntrial</span><span class="o">=</span><span class="n">Ntrial</span>
            <span class="p">)</span>
            <span class="n">sigma_derivative</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">mc_sandwich</span><span class="p">(</span>
                    <span class="n">d_omega</span><span class="p">,</span>
                    <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                    <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">d_omega</span> <span class="ow">in</span> <span class="n">z</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">power_fixed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">variance</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tweedie&quot;</span><span class="p">,</span> <span class="s2">&quot;binomialP&quot;</span><span class="p">]:</span>

                    <span class="n">sigma_derivative_power</span> <span class="o">=</span> <span class="n">mc_sandwich_power</span><span class="p">(</span>
                        <span class="n">omegas</span><span class="p">,</span>
                        <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                        <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;derivative_variance_sqrt_power&quot;</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">sigma_derivative</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma_derivative_power</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">variance</span> <span class="o">==</span> <span class="s2">&quot;binomialPQ&quot;</span><span class="p">:</span>
                    <span class="n">sigma_derivative_p</span> <span class="o">=</span> <span class="n">mc_sandwich</span><span class="p">(</span>
                        <span class="n">omegas</span><span class="p">,</span>
                        <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                        <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;derivative_variance_sqrt_p&quot;</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">sigma_derivative_q</span> <span class="o">=</span> <span class="n">mc_sandwich</span><span class="p">(</span>
                        <span class="n">omegas</span><span class="p">,</span>
                        <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                        <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;derivative_variance_sqrt_q&quot;</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">sigma_derivative</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">sigma_derivative</span><span class="p">,</span>
                        <span class="n">sigma_derivative_p</span><span class="p">,</span>
                        <span class="n">sigma_derivative_q</span><span class="p">,</span>
                    <span class="p">]</span>
        <span class="k">elif</span> <span class="n">variance</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;poisson_tweedie&quot;</span><span class="p">,</span> <span class="s2">&quot;geom_tweedie&quot;</span><span class="p">]:</span>
            <span class="n">variance_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_variance</span><span class="p">(</span>
                <span class="n">variance_type</span><span class="o">=</span><span class="s2">&quot;power&quot;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">),</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span> <span class="n">Ntrial</span><span class="o">=</span><span class="n">Ntrial</span>
            <span class="p">)</span>
            <span class="n">sigma_derivative</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">mc_sandwich</span><span class="p">(</span>
                    <span class="n">d_omega</span><span class="p">,</span>
                    <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                    <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">d_omega</span> <span class="ow">in</span> <span class="n">z</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">power_fixed</span><span class="p">:</span>
                <span class="n">sigma_derivative_power</span> <span class="o">=</span> <span class="n">mc_sandwich_power</span><span class="p">(</span>
                    <span class="n">omegas</span><span class="p">,</span>
                    <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variance_sqrt_output&quot;</span><span class="p">),</span>
                    <span class="n">variance_components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;derivative_variance_sqrt_power&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">sigma_derivative</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma_derivative_power</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sigma_derivative</span><span class="o">=</span><span class="n">sigma_derivative</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sigma_between_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">n_resp</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">forcesymmetric</span><span class="p">(</span><span class="n">sigmab</span><span class="p">):</span>
            <span class="n">sigmab_t</span> <span class="o">=</span> <span class="n">sigmab</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">sigmabsymmetric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">sigmab_t</span><span class="p">,</span> <span class="n">sigmab_t</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="n">diagonal_value</span> <span class="o">=</span> <span class="n">sigmabsymmetric</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diagonal_value</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diagonal_value</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sigmabsymmetric</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigmabsymmetric</span> <span class="o">=</span> <span class="n">sigmab</span>
                <span class="n">sigmabsymmetric</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">n_resp</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rho</span>
                <span class="k">return</span> <span class="n">sigmabsymmetric</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;sigma between method computes between for sequence calculations.</span>

<span class="sd">        It responds out with 2-position-tuple with sigma between and its derivative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_resp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigmab</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">n_resp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_resp</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">sigmab</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">n_resp</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rho</span>
            <span class="n">sigmab</span> <span class="o">=</span> <span class="n">forcesymmetric</span><span class="p">(</span><span class="n">sigmab</span><span class="p">)</span>

            <span class="n">d_sigmab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mc_derivative_sigma_between</span><span class="p">(</span><span class="n">n_resp</span><span class="o">=</span><span class="n">n_resp</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sigmab</span><span class="p">,</span> <span class="n">d_sigmab</span><span class="p">)</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_mc_derivative_sigma_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_resp</span><span class="p">):</span>
        <span class="n">list_derivatives</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">position</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_resp</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">n_par</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_resp</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_resp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_par</span><span class="p">):</span>
            <span class="n">derivative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_resp</span><span class="p">,</span> <span class="n">n_resp</span><span class="p">))</span>
            <span class="n">derivative</span><span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">derivative</span><span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">list_derivatives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">derivative</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">list_derivatives</span>

    <span class="k">def</span> <span class="nf">__derivative_cholesky</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_sigma</span><span class="p">,</span> <span class="n">inv_chol</span><span class="p">,</span> <span class="n">chol</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">faux</span><span class="p">(</span><span class="n">d_sigma</span><span class="p">,</span> <span class="n">inv_chol</span><span class="p">,</span> <span class="n">chol</span><span class="p">,</span> <span class="n">inv_chol_transpose</span><span class="p">):</span>
            <span class="n">csr_d_sigma_matrix</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">d_sigma</span><span class="p">)</span>
            <span class="n">csr_inv_chol_matrix</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">inv_chol</span><span class="p">)</span>
            <span class="n">csr_inv_chol_transpose_matrix</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">inv_chol_transpose</span><span class="p">)</span>

            <span class="n">matrix_operations</span> <span class="o">=</span> <span class="n">csr_inv_chol_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">csr_d_sigma_matrix</span><span class="p">)</span>
            <span class="n">matrix_operations</span> <span class="o">=</span> <span class="n">matrix_operations</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">csr_inv_chol_transpose_matrix</span><span class="p">)</span>

            <span class="n">matrix_operations</span> <span class="o">=</span> <span class="n">tril</span><span class="p">(</span><span class="n">matrix_operations</span><span class="p">)</span>
            <span class="n">matrix_operations</span> <span class="o">=</span> <span class="n">matrix_operations</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

            <span class="n">diagonal_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices_from</span><span class="p">(</span><span class="n">matrix_operations</span><span class="p">)</span>
            <span class="n">matrix_operations</span><span class="p">[</span><span class="n">diagonal_indices</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">matrix_operations</span><span class="p">[</span><span class="n">diagonal_indices</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chol</span><span class="p">,</span> <span class="n">matrix_operations</span><span class="p">)</span>

        <span class="n">cholesky_element</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inv_chol_transpose</span> <span class="o">=</span> <span class="n">inv_chol</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">d_sigma</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">derivative</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">cholesky_element</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">faux</span><span class="p">(</span><span class="n">derivative</span><span class="p">,</span> <span class="n">inv_chol</span><span class="p">,</span> <span class="n">chol</span><span class="p">,</span> <span class="n">inv_chol_transpose</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">der</span> <span class="ow">in</span> <span class="n">derivative</span><span class="p">:</span>
                    <span class="n">cholesky_element</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">faux</span><span class="p">(</span><span class="n">der</span><span class="p">,</span> <span class="n">inv_chol</span><span class="p">,</span> <span class="n">chol</span><span class="p">,</span> <span class="n">inv_chol_transpose</span><span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">derivative</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">cholesky_element</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cholesky_element</span>

    <span class="k">def</span> <span class="nf">__mc_transform_list_bdiag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_mat</span><span class="p">,</span> <span class="n">response_number</span><span class="p">,</span> <span class="n">number_of_labels</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">build_block_diag</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">response_number</span><span class="p">):</span>
            <span class="n">block_value</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="n">matrix_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">block_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_labels</span><span class="p">,</span>
                    <span class="n">block_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_labels</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">lower</span> <span class="o">=</span> <span class="n">block_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">response_number</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">block_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">block_value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">response_number</span>

            <span class="n">matrix_base</span><span class="p">[</span><span class="n">lower</span><span class="p">:</span><span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">:</span><span class="n">upper</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_value</span>

            <span class="k">return</span> <span class="n">matrix_base</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_block_diag</span><span class="p">(</span><span class="n">d_chol</span><span class="p">,</span> <span class="n">response_number</span><span class="p">)</span> <span class="k">for</span> <span class="n">d_chol</span> <span class="ow">in</span> <span class="n">list_mat</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_generate_variance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variance_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">power</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ntrial</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_variance</span><span class="p">(</span><span class="n">variance_type</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">Ntrial</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__generate_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance_type</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ntrial</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method to apply the variance function on the mean values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            variance_type : array_like</span>
<span class="sd">                Type of variance</span>
<span class="sd">            mu : array_like</span>
<span class="sd">                A vector with expected values.</span>
<span class="sd">            power : float</span>
<span class="sd">                A power parameter.</span>
<span class="sd">            Ntrial : int</span>
<span class="sd">                The number of trial. Parameter for Binomial distribution.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            array_like : A matrix with Sigma values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variance_type</span> <span class="o">==</span> <span class="s2">&quot;power&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__power_variance</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">variance_type</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__variance_constant</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">variance_type</span> <span class="o">==</span> <span class="s2">&quot;binomialP&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binomialp_variance</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">Ntrial</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">variance_type</span> <span class="o">==</span> <span class="s2">&quot;binomialPQ&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binomialpq_variance</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">Ntrial</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__variance_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
        <span class="n">mu_power</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="n">power</span>
        <span class="n">n_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

        <span class="n">variance_sqrt_output</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">mu_power</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">variance_sqrt_output</span><span class="o">=</span><span class="n">variance_sqrt_output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__power_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
        <span class="n">mu_power</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="n">power</span>
        <span class="n">sqrt_mu_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu_power</span><span class="p">)</span>
        <span class="n">n_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

        <span class="n">variance_sqrt_output</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">sqrt_mu_power</span><span class="p">)</span>
        <span class="n">derivative_variance_sqrt_power</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">((</span><span class="n">mu_power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sqrt_mu_power</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">derivative_variance_sqrt_mu</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="n">power</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sqrt_mu_power</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">variance_sqrt_output</span><span class="o">=</span><span class="n">variance_sqrt_output</span><span class="p">,</span>
            <span class="n">derivative_variance_sqrt_power</span><span class="o">=</span><span class="n">derivative_variance_sqrt_power</span><span class="p">,</span>
            <span class="n">derivative_variance_sqrt_mu</span><span class="o">=</span><span class="n">derivative_variance_sqrt_mu</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__binomialp_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">ntrial</span><span class="p">):</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ntrial</span>
        <span class="n">mu_power</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="n">power</span>
        <span class="n">mu_power1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="n">power</span>
        <span class="n">mu1mu</span> <span class="o">=</span> <span class="n">constant</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu_power</span> <span class="o">*</span> <span class="n">mu_power1</span><span class="p">)</span>
        <span class="n">sqrt_mu1mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu1mu</span><span class="p">)</span>
        <span class="n">n_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

        <span class="n">variance_sqrt_output</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">sqrt_mu1mu</span><span class="p">)</span>
        <span class="n">derivative_variance_sqrt_power</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu1mu</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu1mu</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sqrt_mu1mu</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">derivative_variance_sqrt_mu</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">constant</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu_power1</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="n">power</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">constant</span> <span class="o">*</span> <span class="p">(((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">power</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">mu_power</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sqrt_mu1mu</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">variance_sqrt_output</span><span class="o">=</span><span class="n">variance_sqrt_output</span><span class="p">,</span>
            <span class="n">derivative_variance_sqrt_power</span><span class="o">=</span><span class="n">derivative_variance_sqrt_power</span><span class="p">,</span>
            <span class="n">derivative_variance_sqrt_mu</span><span class="o">=</span><span class="n">derivative_variance_sqrt_mu</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__binomialpq_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">ntrial</span><span class="p">):</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ntrial</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="n">p</span>
        <span class="n">mu1_q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="n">q</span>
        <span class="n">mu_p_mu_q</span> <span class="o">=</span> <span class="n">mu_p</span> <span class="o">*</span> <span class="n">mu1_q</span>
        <span class="n">mu1mu</span> <span class="o">=</span> <span class="n">mu_p_mu_q</span> <span class="o">*</span> <span class="n">constant</span>
        <span class="n">sqrt_mu1mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu1mu</span><span class="p">)</span>
        <span class="n">n_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

        <span class="n">denominator1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sqrt_mu1mu</span>
        <span class="n">denominator2</span> <span class="o">=</span> <span class="n">denominator1</span> <span class="o">*</span> <span class="n">ntrial</span>

        <span class="n">variance_sqrt_output</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">sqrt_mu1mu</span><span class="p">)</span>

        <span class="n">derivative_variance_sqrt_p</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="n">mu_p_mu_q</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">/</span> <span class="n">denominator2</span>
        <span class="p">)</span>

        <span class="n">derivative_variance_sqrt_q</span> <span class="o">=</span> <span class="n">diagonal</span><span class="p">(</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n_len</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="n">mu_p_mu_q</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">))</span> <span class="o">/</span> <span class="n">denominator2</span>
        <span class="p">)</span>

        <span class="n">derivative_variance_sqrt_mu</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">constant</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu1_q</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">constant</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu_p</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">denominator1</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">variance_sqrt_output</span><span class="o">=</span><span class="n">variance_sqrt_output</span><span class="p">,</span>
            <span class="n">derivative_variance_sqrt_p</span><span class="o">=</span><span class="n">derivative_variance_sqrt_p</span><span class="p">,</span>
            <span class="n">derivative_variance_sqrt_q</span><span class="o">=</span><span class="n">derivative_variance_sqrt_q</span><span class="p">,</span>
            <span class="n">derivative_variance_sqrt_mu</span><span class="o">=</span><span class="n">derivative_variance_sqrt_mu</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__parser_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">build_sigma_map</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;parser method for _calculate_sigma output attributes</span>
<span class="sd">        Args:</span>
<span class="sd">            build_sigma_map (list): a list with dicts, with sigmas</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">list_sigmas</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">build_sigma_iteration</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigma_raw&quot;</span><span class="p">),</span>
                <span class="n">build_sigma_iteration</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigma_chol&quot;</span><span class="p">),</span>
                <span class="n">build_sigma_iteration</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigma_chol_inv&quot;</span><span class="p">),</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">build_sigma_iteration</span> <span class="ow">in</span> <span class="n">build_sigma_map</span>
        <span class="p">]</span>

        <span class="n">sigma_raw</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sigmas</span> <span class="ow">in</span> <span class="n">list_sigmas</span><span class="p">]</span>
        <span class="n">sigma_chol</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigmas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">sigmas</span> <span class="ow">in</span> <span class="n">list_sigmas</span><span class="p">]</span>
        <span class="n">sigma_chol_inv</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigmas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">sigmas</span> <span class="ow">in</span> <span class="n">list_sigmas</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">sigma_raw</span><span class="p">,</span> <span class="n">sigma_chol</span><span class="p">,</span> <span class="n">sigma_chol_inv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__parser_sigma_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_derivatives_map</span><span class="p">):</span>
        <span class="n">list_sigmas</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">build_sigma_iteration</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sigma_derivative&quot;</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">build_sigma_iteration</span> <span class="ow">in</span> <span class="n">sigma_derivatives_map</span>
        <span class="p">]</span>
        <span class="n">sigma_derivative</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sigmas</span> <span class="ow">in</span> <span class="n">list_sigmas</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sigma_derivative</span>

    <span class="k">def</span> <span class="nf">__parser_c_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_c_components</span><span class="p">):</span>

        <span class="n">sigma_chol_block_matrix</span> <span class="o">=</span> <span class="n">raw_c_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sigma_chol_inv_block_matrix</span> <span class="o">=</span> <span class="n">raw_c_components</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c_inverse</span> <span class="o">=</span> <span class="n">raw_c_components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">sigma_chol_block_matrix</span><span class="p">,</span> <span class="n">sigma_chol_inv_block_matrix</span><span class="p">,</span> <span class="n">c_inverse</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Jean Carlos Faoot Maia.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>